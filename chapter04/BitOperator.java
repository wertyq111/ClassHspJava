/**
 * 位运算操作
 * @author zhouxufeng
 * @version 1.0
 */
public class BitOperator
{
	public static void main(String[] args)
	{

        //位运算规则
        //按位与&:     两位全为1, 结果为1, 否则为0
        //按位或|:     两位有一个为1, 结果为1, 否则为0
        //按位异或^:   两位一个为1,一个为0, 结果为1, 否则为0
        //按位取反~:   0 -> 1, 1 -> 0
        //算术右移>>:  低位溢出,符号位不变,并用符号位补溢出的高位(溢出可以理解为扔掉)
        //算术左移<<:  符号位不变,低位补0
        //逻辑右移>>>: 也叫无符号右移,运算规则是:低位溢出,高位补0
        //特别说明:没有<<<符号

        //推导按位与&
        // 1.2的原码: 00000000 00000000 00000000 00000010
        //   2的补码: 00000000 00000000 00000000 00000010
        // 2.3的原码: 00000000 00000000 00000000 00000011
        //   3的补码: 00000000 00000000 00000000 00000011
        // 3.按位&运算
        //   00000000 00000000 00000000 00000010
        //   00000000 00000000 00000000 00000011
        //   & 运算后的补码: 00000000 00000000 00000000 00000010 
        //   运算后原码: 00000000 00000000 00000000 00000010
        // 4. 结果: 2
        System.out.println(2&3);

        //推导按位取反~
        // 1. -2的原码: 10000000 00000000 00000000 00000010
        // 2. -2的反码: 11111111 11111111 11111111 11111101
        // 3. -2的补码: 11111111 11111111 11111111 11111110
        // 4. 按位~运算
        //     1. ~ 运算后的补码: 00000000 00000000 00000000 00000001 (首位是0则为正数,三码合一)
        //     2. ~ 运算后的原码: 00000000 00000000 00000000 00000001
        //     3. ~ 运算后的结果: 1
        System.out.println(~-2);

        //推导按位取反~
        // 1. 2的补码: 00000000 00000000 00000000 00000010
        // 2. 按位~运算
        //     1. ~ 运算后的补码: 11111111 11111111 11111111 11111101
        //     2. ~ 运算后的反码: 11111111 11111111 11111111 11111100 (补码 = 反码 + 1)
        //     3. ~ 运算后的原码: 10000000 00000000 00000000 00000011
        //     4. ~ 运算后的结果: -3
        System.out.println(~2);

        //推导按位或|
        // 1. 2的补码: 00000000 00000000 00000000 00000010
        // 2. 3的补码: 00000000 00000000 00000000 00000011
        // 3. 按位|运算
        //     1. | 运算后的补码: 00000000 00000000 00000000 00000011
        //     2. | 运算后的原码: 00000000 00000000 00000000 00000011
        //     3. | 运算后的结果: 3
        System.out.println(2|3);

        //推导按位异或^
        // 1. 2的补码: 00000000 00000000 00000000 00000010
        // 2. 3的补码: 00000000 00000000 00000000 00000011
        // 3. 按位^运算
        //     1. ^ 运算后的补码: 00000000 00000000 00000000 00000001
        //     2. ^ 运算后的原码: 00000000 00000000 00000000 00000001
        //     3. ^ 运算后的结果: 1
        System.out.println(2^3);

        int a = 1>>2;
        int b = 1<<2;

        //推导算术右移>>
        //  1. 1的补码: 00000000 00000000 00000000 00000001
        //  2. 算数右移>>运算
        //     1. >> 运算后的补码: 00000000 00000000 00000000 00000000 (低位00000001右移2位 = 1 / 2 / 2 = 0)
        //     2. >> 运算后的原码: 00000000 00000000 00000000 00000000
        //     3. >> 运算后的结果: 0
        System.out.println(a);

        //推导算术左移<<
        //  1. 1的补码: 00000000 00000000 00000000 00000001
        //  2. 算数左移<<运算
        //     1. << 运算后的补码: 00000000 00000000 00000000 00000100 (低位00000001左移2位 = 1 * 2 * 2 = 4)
        //     2. << 运算后的原码: 00000000 00000000 00000000 00000100
        //     3. << 运算后的结果: 4
        System.out.println(b);

    }
}